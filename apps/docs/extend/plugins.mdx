---
title: 'Plugins'
description: 'Extend beyond the core functionality with plugins.'
icon: 'cube'
---

## Overview

Plugins are a powerful way to extend the core functionality of @dnd-kit. They can be used to add new features, modify existing behavior, or react to drag and drop operations.

## Built-in Plugins

Several plugins are included by default:

- `Accessibility`: Manages ARIA attributes for drag and drop operations
- `AutoScroller`: Automatically scrolls containers when dragging near edges
- `Cursor`: Updates cursor styles during drag operations
- `Feedback`: Manages visual feedback during dragging
- `PreventSelection`: Prevents text selection while dragging
- `ScrollListener`: Tracks scroll events during drag operations
- `Scroller`: Handles programmatic scrolling

### Feedback

The `Feedback` plugin manages the visual appearance of elements during drag operations. It promotes dragged elements to the browser's [top layer](https://developer.mozilla.org/en-US/docs/Glossary/Top_layer) using the [Popover API](https://developer.mozilla.org/en-US/docs/Web/API/Popover_API), and injects CSS rules to handle positioning and to reset browser default popover styles.

#### Configuration

Use `Feedback.configure()` to customize the drop animation:

```ts
import {DragDropManager, Feedback} from '@dnd-kit/dom';

const manager = new DragDropManager({
  plugins: (defaults) => [
    ...defaults,
    Feedback.configure({ dropAnimation: null }),
  ],
});
```

#### CSS cascade layer

The Feedback plugin uses a CSS cascade layer named `dnd-kit` to reset user-agent popover styles (such as `background`, `border`, `margin`, and `padding`) that browsers apply to elements promoted to the top layer.

By default, this layer is injected at the beginning of the document's `<head>`, giving it the lowest cascade priority. This means your styles will take precedence without needing `!important`.

If you use a CSS framework that defines its own cascade layers (such as Tailwind CSS v4), you can explicitly declare the `dnd-kit` layer first to ensure it has the lowest priority:

```css
@layer dnd-kit, base, components, utilities;
```

## Creating a Plugin

To create a custom plugin, extend the `Plugin` class:

```ts
import {Plugin} from '@dnd-kit/abstract';

interface MyPluginOptions {
  delay?: number;
}

class MyPlugin extends Plugin {
  constructor(manager, options?: MyPluginOptions) {
    super(manager, options);

    // Register effects that will be cleaned up automatically
    this.registerEffect(() => {
      const {monitor} = this.manager;

      // Listen for drag events
      const cleanup = monitor.addEventListener('dragstart', (event) => {
        console.log('Drag started:', event.operation.source.id);
      });

      // Return cleanup function
      return cleanup;
    });
  }

  // Optional: Add custom methods
  public customMethod() {
    if (this.disabled) return;
    // Custom functionality
  }
}
```

## Using Plugins

The `plugins` option accepts either an array or a function that receives the default plugins.

### Extending defaults

Use the function form to add plugins to the defaults or configure existing ones, without replacing them:

```ts
import {DragDropManager} from '@dnd-kit/dom';

const manager = new DragDropManager({
  // Add a custom plugin alongside the defaults
  plugins: (defaults) => [...defaults, MyPlugin],
});
```

```ts
// Configure an existing default plugin
const manager = new DragDropManager({
  plugins: (defaults) => [
    ...defaults,
    Feedback.configure({ dropAnimation: null }),
  ],
});
```

### Replacing defaults

Pass an array to fully replace the default plugins:

```ts
const manager = new DragDropManager({
  plugins: [
    MyPlugin.configure({ delay: 500 }),
    AutoScroller,
  ]
});
```

## Plugin Lifecycle

1. **Construction**: Plugin instance created with manager reference
2. **Configuration**: Options applied if provided
3. **Registration**: Plugin registered with manager
4. **Operation**: Plugin effects are run
5. **Cleanup**: Plugin destroyed when manager is destroyed

## API Reference

### Plugin Class

The base class for all plugins:

<ParamField path="manager" type="DragDropManager" required>
  Reference to the drag and drop manager instance.
</ParamField>

<ParamField path="options" type="PluginOptions">
  Optional configuration options for the plugin.
</ParamField>

### Properties

- `disabled`: Whether the plugin is currently disabled
- `options`: Current plugin options

### Methods

- `enable()`: Enable the plugin
- `disable()`: Disable the plugin
- `isDisabled()`: Check if plugin is disabled
- `configure(options)`: Update plugin options
- `destroy()`: Clean up plugin resources
- `registerEffect(callback)`: Register a reactive effect

### Static Methods

- `configure(options)`: Create a configured plugin descriptor

```ts
// Example using static configure
const configuredPlugin = MyPlugin.configure({
  delay: 500
});

const manager = new DragDropManager({
  plugins: [configuredPlugin]
});
```

### Plugin Options

Options passed to plugins should be plain objects:

```ts
interface PluginOptions {
  [key: string]: any;
}
```

### Effects

Plugins can register effects that automatically clean up:

```ts
class MyPlugin extends Plugin {
  constructor(manager) {
    super(manager);

    // Effect will be cleaned up when plugin is destroyed
    this.registerEffect(() => {
      const interval = setInterval(() => {
        // Do something periodically
      }, 100);

      return () => clearInterval(interval);
    });
  }
}
```

### Best Practices

1. **Clean Up Resources**: Always clean up listeners and timers in the `destroy` method
2. **Check Disabled State**: Check `this.disabled` before performing operations
3. **Use Type Safety**: Leverage TypeScript for better type checking
4. **Document Options**: Clearly document all available options
5. **Follow Patterns**: Study built-in plugins for patterns and conventions
